package hical

//MergeRanges merges meeting ranges
func MergeRanges(meetings [][]int) [][]int {

	//Store merged meetings in new array
	var merged [][]int
	meetings = Sort(meetings)

	//Set min and max with start and end of first meeting
	var min, max int = meetings[0][0], meetings[0][1]

	for i := 1; i < len(meetings); i++ {
		//Update max time if the next meeting overlaps:
		// - start time <= current max
		// - end time > current max
		if meetings[i][0] <= max {
			if meetings[i][1] > max {
				max = meetings[i][1]
			}
		} else {
			//If new meeting does not overlap, append to merged array
			merged = append(merged, []int{min, max})
			//Set min,max again with next meeting's start and end times
			min, max = meetings[i][0], meetings[i][1]
		}
	}
	//Append last min,max for last meeting
	merged = append(merged, []int{min, max})

	return merged

}

//Sort sorts the meetings using the merge sort algorithm
func Sort(meetings [][]int) [][]int {
	length := len(meetings)
	if length < 2 {
		return meetings
	}
	var mid = length / 2
	result := merge(Sort(meetings[:mid]), Sort(meetings[mid:]))
	return result
}

//Merges the meeting arrays generated by the Sort function
func merge(left, right [][]int) [][]int {
	llen, rlen, l, r, i := len(left), len(right), 0, 0, 0

	var slice = make([][]int, len(left)+len(right))

	for l < llen || r < rlen {
		if (l < llen && r < rlen && left[l][0] <= right[r][0]) || (r == rlen && l < llen) {
			slice[i] = left[l]
			l++
		} else {
			slice[i] = right[r]
			r++
		}
		i++
	}

	return slice
}
